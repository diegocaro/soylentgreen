    <html>
    <head>
      <title>NAS Timeline Viewer</title>
      <script src="https://unpkg.com/vis-timeline@7.7.0/standalone/umd/vis-timeline-graph2d.min.js"></script>
      <link href="https://unpkg.com/vis-timeline@7.7.0/styles/vis-timeline-graph2d.min.css" rel="stylesheet" />
      <style>
        body { font-family: sans-serif; padding: 10px; }
        .header { display: flex; justify-content: space-between; align-items: center;  }
        .header h2 { margin-top: 0; }
        .camera-selector { text-align: right; }
        #overviewTimeline { border: 1px solid #ccc; height: 80px; cursor: pointer; position: relative; margin-bottom: 10px; background: #f5f5f5; }
        #detailRangeIndicator {
          position: absolute;
          top: 0;
          bottom: 0;
          background: rgba(33, 150, 243, 0.2);
          border-left: 2px solid rgba(33, 150, 243, 0.8);
          border-right: 2px solid rgba(33, 150, 243, 0.8);
          pointer-events: none;
          z-index: 10;
        }
        #timeline { border: 1px solid #ccc; height: 100px; cursor: pointer; position: relative; }
        video { margin-top: 20px; width: 720px; height: 405px; }
        .timeTooltip {
          position: absolute;
          background: rgba(0, 0, 0, 0.8);
          color: white;
          padding: 5px 10px;
          border-radius: 4px;
          font-size: 12px;
          pointer-events: none;
          display: none;
          z-index: 1000;
          white-space: nowrap;
        }
        .scrubLine {
          position: absolute;
          width: 2px;
          background: rgba(255, 0, 0, 0.7);
          pointer-events: none;
          display: none;
          z-index: 999;
          top: 0;
          bottom: 0;
        }
        .playbackIndicator {
          position: absolute;
          width: 3px;
          background: rgba(255, 0, 0, 0.9);
          pointer-events: none;
          z-index: 998;
          top: 0;
          bottom: 0;
          display: none;
        }
        .availability-marker {
          position: absolute;
          bottom: 0;
          height: 20px;
          background: linear-gradient(180deg, rgba(76, 175, 80, 0.3), rgba(76, 175, 80, 0.6));
          pointer-events: none;
        }
        .label-marker {
          position: absolute;
          top: 0;
          height: 100%;
          background: rgba(255, 152, 0, 0.3);
          border-left: 1px solid rgba(255, 152, 0, 0.7);
          border-right: 1px solid rgba(255, 152, 0, 0.7);
          pointer-events: none;
          z-index: 5;
        }
        .label-legend {
          margin-top: 10px;
          margin-bottom: 15px;
          font-size: 12px;
          color: #666;
        }
        .label-legend-item {
          display: inline-block;
          margin-right: 15px;
        }
        .label-legend-color {
          display: inline-block;
          width: 20px;
          height: 12px;
          margin-right: 5px;
          vertical-align: middle;
          border: 1px solid rgba(0, 0, 0, 0.2);
        }
        .timeline-label {
          font-size: 11px;
          color: #666;
          margin-bottom: 3px;
        }
      </style>
    </head>
    <body>
      <div class="header">
        <h2>NAS Video Timeline</h2>
        <div class="camera-selector">
          <label for="cameraSelect">Camera: </label>
          <select id="cameraSelect">
            <option value="">Loading cameras...</option>
          </select>
        </div>
      </div>
      <div class="timeline-label">Overview (click to jump to date/time):</div>
      <div style="position: relative;">
        <div id="overviewTimeline"></div>
        <div id="detailRangeIndicator"></div>
        <div id="overviewScrubLine" class="scrubLine"></div>
        <div id="overviewTooltip" class="timeTooltip"></div>
        <div id="overviewPlaybackIndicator" class="playbackIndicator"></div>
      </div>
      <div class="timeline-label">Detailed view:</div>
      <div style="position: relative;">
        <div id="timeline"></div>
        <div id="scrubLine" class="scrubLine"></div>
        <div id="timeTooltip" class="timeTooltip"></div>
        <div id="playbackIndicator" class="playbackIndicator"></div>
      </div>
      <div id="labelLegend" class="label-legend"></div>
      <div id="playerContainer" style="position:relative; width:720px; height:405px;">
        <video id="playerA" controls playsinline style="position:absolute; top:0; left:0; width:100%; height:100%; z-index:2; transition: opacity 300ms;" ></video>
        <video id="playerB" controls playsinline style="position:absolute; top:0; left:0; width:100%; height:100%; z-index:1; transition: opacity 300ms;" ></video>
      </div>

<script>
let camera_id = null;

// Label color mapping
const LABEL_COLORS = {
  'box': 'rgba(255, 152, 0, 0.3)',
  'person': 'rgba(33, 150, 243, 0.3)',
  'car': 'rgba(244, 67, 54, 0.3)',
  'default': 'rgba(156, 39, 176, 0.3)'
};

const LABEL_BORDER_COLORS = {
  'box': 'rgba(255, 152, 0, 0.7)',
  'person': 'rgba(33, 150, 243, 0.7)',
  'car': 'rgba(244, 67, 54, 0.7)',
  'default': 'rgba(156, 39, 176, 0.7)'
};

function getLabelColor(labelName) {
  return LABEL_COLORS[labelName] || LABEL_COLORS['default'];
}

function getLabelBorderColor(labelName) {
  return LABEL_BORDER_COLORS[labelName] || LABEL_BORDER_COLORS['default'];
}

async function loadCameras() {
  const res = await fetch('/cameras');
  const cameras = await res.json();
  const select = document.getElementById('cameraSelect');
  select.innerHTML = '';
  
  if (cameras.length === 0) {
    select.innerHTML = '<option value="">No cameras found</option>';
    return null;
  }
  
  cameras.forEach(cam => {
    const option = document.createElement('option');
    option.value = cam.id;
    option.textContent = cam.name;
    select.appendChild(option);
  });
  
  // Select first camera by default
  camera_id = cameras[0].id;
  select.value = camera_id;
  
  // Handle camera change
  select.addEventListener('change', (e) => {
    camera_id = e.target.value;
    initTimeline();
  });
  
  return camera_id;
}

function renderLabelMarkers(container, labels, timelineObj) {
  // Remove existing label markers
  const existingMarkers = container.querySelectorAll('.label-marker');
  existingMarkers.forEach(marker => marker.remove());
  
  if (!labels || !labels.labels) return;
  
  const timelineRange = timelineObj.getWindow();
  const containerWidth = container.clientWidth;
  const timeSpan = timelineRange.end - timelineRange.start;
  
  // Render markers for each label type
  Object.entries(labels.labels).forEach(([labelName, labelTimeline]) => {
    const color = getLabelColor(labelName);
    const borderColor = getLabelBorderColor(labelName);
    
    labelTimeline.intervals.forEach(interval => {
      const start = new Date(interval.start);
      const end = new Date(interval.end);
      
      // Only render if interval intersects with visible range
      if (end >= timelineRange.start && start <= timelineRange.end) {
        const marker = document.createElement('div');
        marker.className = 'label-marker';
        marker.style.background = color;
        marker.style.borderLeft = `1px solid ${borderColor}`;
        marker.style.borderRight = `1px solid ${borderColor}`;
        marker.title = `${labelName}: ${start.toLocaleString()} - ${end.toLocaleString()}`;
        
        const startOffset = Math.max(0, (start - timelineRange.start) / timeSpan);
        const endOffset = Math.min(1, (end - timelineRange.start) / timeSpan);
        
        marker.style.left = (startOffset * containerWidth) + 'px';
        marker.style.width = ((endOffset - startOffset) * containerWidth) + 'px';
        
        container.appendChild(marker);
      }
    });
  });
}

function updateLabelLegend(labels) {
  const legendContainer = document.getElementById('labelLegend');
  legendContainer.innerHTML = '';
  
  if (!labels || !labels.labels || Object.keys(labels.labels).length === 0) {
    return;
  }
  
  legendContainer.innerHTML = '<strong>Detected labels:</strong> ';
  
  Object.keys(labels.labels).forEach(labelName => {
    const item = document.createElement('span');
    item.className = 'label-legend-item';
    
    const colorBox = document.createElement('span');
    colorBox.className = 'label-legend-color';
    colorBox.style.background = getLabelColor(labelName);
    colorBox.style.borderColor = getLabelBorderColor(labelName);
    
    item.appendChild(colorBox);
    item.appendChild(document.createTextNode(labelName));
    legendContainer.appendChild(item);
  });
}

async function initTimeline() {
  if (!camera_id) return;
  
  // Destroy existing timelines if they exist
  if (window._sg_timeline) {
    window._sg_timeline.destroy();
    window._sg_timeline = null;
  }
  if (window._sg_overviewTimeline) {
    window._sg_overviewTimeline.destroy();
    window._sg_overviewTimeline = null;
  }
  
  const res = await fetch('/list-intervals?camera_id=' + encodeURIComponent(camera_id));
  const intervals = await res.json();
  
  // Fetch labels for this camera
  const labelsRes = await fetch('/labels?camera_id=' + encodeURIComponent(camera_id));
  const labels = await labelsRes.json();
  window._sg_labels = labels;
  const items = intervals.map((interval, i) => ({
    id: i,
    content: '',
    start: interval.start,
    end: interval.end
  }));

  // Create overview timeline
  const overviewContainer = document.getElementById('overviewTimeline');
  const overviewTooltip = document.getElementById('overviewTooltip');
  const overviewScrubLine = document.getElementById('overviewScrubLine');
  
  // Create simplified items for overview (group by day for better performance)
  const overviewItems = items.map((item, i) => ({
    id: 'overview_' + i,
    content: '',
    start: item.start,
    end: item.end,
    className: 'overview-item'
  }));
  
  const overviewTimeline = new vis.Timeline(overviewContainer, overviewItems, {
    selectable: false,
    zoomMin: 1000 * 60 * 60 * 24, // 1 day minimum
    zoomMax: 1000 * 60 * 60 * 24 * 365, // 1 year maximum
    stack: false,
    showCurrentTime: false,
    showMajorLabels: true,
    showMinorLabels: true
  });
  
  window._sg_overviewTimeline = overviewTimeline;
  
  // Render labels on overview timeline after it's ready
  setTimeout(() => {
    renderLabelMarkers(overviewContainer, labels, overviewTimeline);
  }, 100);

  // Create detailed timeline
  const container = document.getElementById('timeline');
  const tooltip = document.getElementById('timeTooltip');
  const scrubLine = document.getElementById('scrubLine');
  
  const timeline = new vis.Timeline(container, items, {
    selectable: true,
    zoomMin: 1000 * 60 * 5,
    zoomMax: 1000 * 60 * 60 * 24,
    stack: false,
    showCurrentTime: true
  });
  
  // Render labels on detailed timeline after it's ready
  setTimeout(() => {
    renderLabelMarkers(container, labels, timeline);
  }, 100);
  
  // Update label legend
  updateLabelLegend(labels);

  // Function to update the detail range indicator
  function updateDetailRangeIndicator() {
    const detailRange = timeline.getWindow();
    const overviewRange = overviewTimeline.getWindow();
    const indicator = document.getElementById('detailRangeIndicator');
    const container = document.getElementById('overviewTimeline');
    
    const containerWidth = container.clientWidth;
    const overviewSpan = overviewRange.end - overviewRange.start;
    
    const startOffset = (detailRange.start - overviewRange.start) / overviewSpan;
    const endOffset = (detailRange.end - overviewRange.start) / overviewSpan;
    
    indicator.style.left = (startOffset * containerWidth) + 'px';
    indicator.style.width = ((endOffset - startOffset) * containerWidth) + 'px';
  }
  
  // Sync overview timeline with detailed timeline and update indicator
  timeline.on('rangechange', () => {
    updateDetailRangeIndicator();
    renderLabelMarkers(container, labels, timeline);
  });
  
  overviewTimeline.on('rangechange', () => {
    updateDetailRangeIndicator();
    renderLabelMarkers(overviewContainer, labels, overviewTimeline);
  });
  
  // Initial update
  setTimeout(updateDetailRangeIndicator, 100);
  
  // Click on overview to jump to that time range and start playing
  overviewContainer.onclick = async (event) => {
    const props = overviewTimeline.getEventProperties(event);
    if (!props.time) return;
    
    // Center the detailed timeline on the clicked time
    const windowSize = 1000 * 60 * 60; // 1 hour window
    const start = new Date(props.time.getTime() - windowSize / 2);
    const end = new Date(props.time.getTime() + windowSize / 2);
    timeline.setWindow(start, end, {animation: true});
    
    // Seek to and play the video at that time
    const t = props.time.toISOString();
    const resp = await fetch('/seek?time=' + encodeURIComponent(t) + '&camera_id=' + encodeURIComponent(camera_id));
    if (!resp.ok) return;
    const { path, offset } = await resp.json();
    
    await loadAndPlay(path, offset || 0, props.time);
  };
  
  // Handle mouse move over overview timeline
  overviewContainer.addEventListener('mousemove', (event) => {
    const props = overviewTimeline.getEventProperties(event);
    if (props.time) {
      const timeDate = new Date(props.time);
      const rect = overviewContainer.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      
      // Format date and time
      const dateStr = timeDate.toLocaleDateString();
      const timeStr = formatTime(timeDate);
      
      overviewTooltip.textContent = `${dateStr} ${timeStr}`;
      overviewTooltip.style.display = 'block';
      overviewTooltip.style.left = `${event.clientX - rect.left + 10}px`;
      overviewTooltip.style.top = `${event.clientY - rect.top - 30}px`;
      
      overviewScrubLine.style.display = 'block';
      overviewScrubLine.style.left = `${mouseX}px`;
    }
  });
  
  overviewContainer.addEventListener('mouseleave', () => {
    overviewTooltip.style.display = 'none';
    overviewScrubLine.style.display = 'none';
  });

  // store intervals globally
  window._sg_intervals = intervals;
  window._sg_timeline = timeline;

  const playerA = document.getElementById('playerA');
  const playerB = document.getElementById('playerB');
  let active = 'A'; // which player is currently visible/active

  function activePlayer() { return active === 'A' ? playerA : playerB; }
  function inactivePlayer() { return active === 'A' ? playerB : playerA; }
  
  // Function to update playback indicator position
  function updatePlaybackIndicator() {
    const player = activePlayer();
    if (!player || player.paused || !player.dataset.seekTimestamp) return;
    
    const seekTimestamp = new Date(player.dataset.seekTimestamp);
    const videoOffset = parseFloat(player.dataset.videoOffset || 0);
    const currentTime = player.currentTime;
    
    // Calculate actual playback time
    const playbackTime = new Date(seekTimestamp.getTime() + (currentTime - videoOffset) * 1000);
    
    // Update detailed timeline indicator
    const detailContainer = document.getElementById('timeline');
    const detailIndicator = document.getElementById('playbackIndicator');
    const detailRange = timeline.getWindow();
    const detailSpan = detailRange.end - detailRange.start;
    
    if (playbackTime >= detailRange.start && playbackTime <= detailRange.end) {
      const detailOffset = (playbackTime - detailRange.start) / detailSpan;
      detailIndicator.style.left = (detailOffset * detailContainer.clientWidth) + 'px';
      detailIndicator.style.display = 'block';
    } else {
      detailIndicator.style.display = 'none';
    }
    
    // Update overview timeline indicator
    const overviewContainer = document.getElementById('overviewTimeline');
    const overviewIndicator = document.getElementById('overviewPlaybackIndicator');
    const overviewRange = overviewTimeline.getWindow();
    const overviewSpan = overviewRange.end - overviewRange.start;
    
    if (playbackTime >= overviewRange.start && playbackTime <= overviewRange.end) {
      const overviewOffset = (playbackTime - overviewRange.start) / overviewSpan;
      overviewIndicator.style.left = (overviewOffset * overviewContainer.clientWidth) + 'px';
      overviewIndicator.style.display = 'block';
    } else {
      overviewIndicator.style.display = 'none';
    }
  }
  
  // Update playback indicator continuously while playing
  setInterval(updatePlaybackIndicator, 100);

  // helper to load into the inactive player, seek when metadata is ready, play and then swap
  async function loadAndPlay(path, offsetSeconds, seekTimestamp) {
    const target = inactivePlayer();
    target.pause();
    target.removeAttribute('src');
    target.src = '/video?path=' + encodeURIComponent(path);
    
    // Store the seek timestamp for calculating next video time
    target.dataset.seekTimestamp = seekTimestamp ? seekTimestamp.toISOString() : null;

    const onMeta = function() {
      // clamp offset
      const seek = Math.max(0, Math.min(offsetSeconds || 0, target.duration || 0));
      
      // Store video duration for auto-advance calculation
      target.dataset.videoDuration = target.duration;
      target.dataset.videoOffset = seek;
      
      // Wait for seek to complete before playing
      const onSeeked = function() {
        target.removeEventListener('seeked', onSeeked);
        
        const onPlaying = function() {
          // bring target on top
          if (active === 'A') {
            playerB.style.zIndex = 3;
            playerA.style.zIndex = 1;
          } else {
            playerA.style.zIndex = 3;
            playerB.style.zIndex = 1;
          }
          // update active flag
          active = (target === playerA) ? 'A' : 'B';
          // pause the now inactive one
          const nowInactive = inactivePlayer();
          try { nowInactive.pause(); } catch (e) {}
          target.removeEventListener('playing', onPlaying);
          
          // Preload next video when current one starts playing
          preloadNextVideo();
        };
        target.addEventListener('playing', onPlaying);
        target.play().catch(() => {/* autoplay may be blocked if not user-initiated */});
      };
      
      target.addEventListener('seeked', onSeeked);
      try { target.currentTime = seek; } catch (e) {}
      target.removeEventListener('loadedmetadata', onMeta);
    };
    target.addEventListener('loadedmetadata', onMeta);
  }
  
  // Preload the next video in the inactive player
  async function preloadNextVideo() {
    const player = activePlayer();
    const seekTimestamp = player.dataset.seekTimestamp;
    const videoOffset = parseFloat(player.dataset.videoOffset || 0);
    const videoDuration = parseFloat(player.dataset.videoDuration || 0);
    
    if (!seekTimestamp) return;
    
    // Calculate when this video will end
    const startTime = new Date(seekTimestamp);
    const playedDuration = videoDuration - videoOffset;
    const endTime = new Date(startTime.getTime() + playedDuration * 1000);
    
    // Get the next video info
    const t = endTime.toISOString();
    const resp = await fetch('/seek?time=' + encodeURIComponent(t) + '&camera_id=' + encodeURIComponent(camera_id));
    if (!resp.ok) return;
    const { path, offset } = await resp.json();
    
    // Preload into inactive player
    const target = inactivePlayer();
    target.pause();
    target.removeAttribute('src');
    target.src = '/video?path=' + encodeURIComponent(path);
    target.preload = 'auto';
    
    // Store metadata for when it's time to play
    target.dataset.seekTimestamp = endTime.toISOString();
    target.dataset.preloadedOffset = offset || 0;
    
    const onMeta = function() {
      target.dataset.videoDuration = target.duration;
      target.dataset.videoOffset = target.dataset.preloadedOffset;
      
      // Seek to the correct position so it's ready to play
      const seek = Math.max(0, Math.min(parseFloat(target.dataset.preloadedOffset || 0), target.duration || 0));
      try { target.currentTime = seek; } catch (e) {}
      target.removeEventListener('loadedmetadata', onMeta);
    };
    target.addEventListener('loadedmetadata', onMeta);
  }

  // Format time for display
  function formatTime(date) {
    const hours = date.getHours().toString().padStart(2, '0');
    const minutes = date.getMinutes().toString().padStart(2, '0');
    const seconds = date.getSeconds().toString().padStart(2, '0');
    return `${hours}:${minutes}:${seconds}`;
  }

  // Handle mouse move over timeline for scrubbing preview
  container.addEventListener('mousemove', (event) => {
    const props = timeline.getEventProperties(event);
    if (props.time) {
      const timeDate = new Date(props.time);
      const rect = container.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      
      // Show tooltip with time
      tooltip.textContent = formatTime(timeDate);
      tooltip.style.display = 'block';
      tooltip.style.left = `${event.clientX - rect.left + 10}px`;
      tooltip.style.top = `${event.clientY - rect.top - 30}px`;
      
      // Show scrub line
      scrubLine.style.display = 'block';
      scrubLine.style.left = `${mouseX}px`;
    }
  });

  // Hide tooltip and scrub line when mouse leaves
  container.addEventListener('mouseleave', () => {
    tooltip.style.display = 'none';
    scrubLine.style.display = 'none';
  });

  // Click on timeline to seek
  container.onclick = async (event) => {
    const props = timeline.getEventProperties(event);
    if (!props.time) return;
    const t = props.time.toISOString();
    const resp = await fetch('/seek?time=' + encodeURIComponent(t) + '&camera_id=' + encodeURIComponent(camera_id));
    if (!resp.ok) return;
    const { path, offset } = await resp.json();
    
    await loadAndPlay(path, offset || 0, props.time);
  };

  // When video ends, swap to preloaded video and play
  playerA.addEventListener('ended', async () => {
    if (active !== 'A') return; // only respond if A is active
    
    // Check if playerB is preloaded and ready
    const target = playerB;
    if (target.src && target.dataset.seekTimestamp && target.readyState >= 2) {
      // Preloaded video is ready, just swap and play
      playerB.style.zIndex = 3;
      playerA.style.zIndex = 1;
      active = 'B';
      playerA.pause();
      
      target.play().catch(() => {});
      preloadNextVideo();
    } else {
      // Fallback: load next video normally
      const seekTimestamp = playerA.dataset.seekTimestamp;
      const videoOffset = parseFloat(playerA.dataset.videoOffset || 0);
      const videoDuration = parseFloat(playerA.dataset.videoDuration || 0);
      
      if (!seekTimestamp) return;
      
      const startTime = new Date(seekTimestamp);
      const playedDuration = videoDuration - videoOffset;
      const endTime = new Date(startTime.getTime() + playedDuration * 1000);
      
      const t = endTime.toISOString();
      const resp = await fetch('/seek?time=' + encodeURIComponent(t) + '&camera_id=' + encodeURIComponent(camera_id));
      if (!resp.ok) return;
      const { path, offset } = await resp.json();
      
      await loadAndPlay(path, offset || 0, endTime);
    }
  });

  playerB.addEventListener('ended', async () => {
    if (active !== 'B') return; // only respond if B is active
    
    // Check if playerA is preloaded and ready
    const target = playerA;
    if (target.src && target.dataset.seekTimestamp && target.readyState >= 2) {
      // Preloaded video is ready, just swap and play
      playerA.style.zIndex = 3;
      playerB.style.zIndex = 1;
      active = 'A';
      playerB.pause();
      
      target.play().catch(() => {});
      preloadNextVideo();
    } else {
      // Fallback: load next video normally
      const seekTimestamp = playerB.dataset.seekTimestamp;
      const videoOffset = parseFloat(playerB.dataset.videoOffset || 0);
      const videoDuration = parseFloat(playerB.dataset.videoDuration || 0);
      
      if (!seekTimestamp) return;
      
      const startTime = new Date(seekTimestamp);
      const playedDuration = videoDuration - videoOffset;
      const endTime = new Date(startTime.getTime() + playedDuration * 1000);
      
      const t = endTime.toISOString();
      const resp = await fetch('/seek?time=' + encodeURIComponent(t) + '&camera_id=' + encodeURIComponent(camera_id));
      if (!resp.ok) return;
      const { path, offset } = await resp.json();
      
      await loadAndPlay(path, offset || 0, endTime);
    }
  });
}

// Initialize app
(async () => {
  await loadCameras();
  await initTimeline();
})();
</script>
    </body>
    </html>
    