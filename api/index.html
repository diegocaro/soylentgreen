<!doctype html>    
    <html>
    <head>
      <title>NAS Timeline Viewer</title>
      <script src="https://unpkg.com/vis-timeline@latest/standalone/umd/vis-timeline-graph2d.min.js"></script>
      <link href="https://unpkg.com/vis-timeline@latest/styles/vis-timeline-graph2d.min.css" rel="stylesheet" />
      <style>
        body { font-family: sans-serif; padding: 10px; }
        .header { display: flex; justify-content: space-between; align-items: center;  }
        .header h2 { margin-top: 0; }
        .camera-selector { text-align: right; }
        #overviewTimeline { border: 1px solid #ccc; border-bottom: none; cursor: pointer; position: relative; background: #f5f5f5; }
        #overviewTimeline .vis-text { font-size: 9px; }
        #timeline .vis-text { font-size: 9px; }
/*       #overviewTimeline .vis-label { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; } */
        #detailRangeIndicator {
          position: absolute;
          top: 0;
          bottom: 0;
          background: rgba(33, 150, 243, 0.2);
          border-left: 2px solid rgba(33, 150, 243, 0.8);
          border-right: 2px solid rgba(33, 150, 243, 0.8);
          pointer-events: auto;
          z-index: 10;
          cursor: move;
        }
        #timeline { border: 1px solid #ccc; border-top: none; cursor: pointer; position: relative; margin-bottom: 10px; }
        video { margin-top: 20px; width: 720px; height: 405px; }
        .timeTooltip {
          position: absolute;
          background: rgba(0, 0, 0, 0.8);
          color: white;
          padding: 5px 10px;
          border-radius: 4px;
          font-size: 12px;
          pointer-events: none;
          display: none;
          z-index: 1000;
          white-space: nowrap;
        }
        .scrubLine {
          position: absolute;
          width: 2px;
          background: rgba(255, 0, 0, 0.7);
          pointer-events: none;
          display: none;
          z-index: 999;
          top: 0;
          bottom: 0;
        }
        .playbackIndicator {
          position: absolute;
          width: 3px;
          background: rgba(255, 0, 0, 0.9);
          pointer-events: none;
          z-index: 1000;
          top: 0;
          height: 100%;
          box-shadow: 0 0 5px rgba(255, 0, 0, 0.5);
        }
        .availability-marker {
          position: absolute;
          bottom: 0;
          height: 20px;
          background: linear-gradient(180deg, rgba(76, 175, 80, 0.3), rgba(76, 175, 80, 0.6));
          pointer-events: none;
        }
        .vis-item.video-segment,
        .vis-item.overview-item {
          background-color: rgba(153, 207, 255, 0.4);
          border: none;
        }
        
        /* Label group and item colors - default for all */
        .vis-labelset .vis-label[class*="label-group-"],
        .vis-item.label-item[class*="label-"] {
          background-color: rgba(156, 39, 176, 0.3) !important;
          border-color: rgba(156, 39, 176, 0.7) !important;
        }
        
        /* Always show groups with minimum height */
        .vis-timeline .vis-labelset .vis-label {
          min-height: 30px !important;
          height: 30px !important;
        }
        
        .vis-timeline .vis-foreground .vis-group {
          min-height: 30px !important;
          height: 30px !important;
        }
        
        /* Specific label colors override default */
        .vis-labelset .vis-label.label-group-box,
        .vis-item.label-item.label-box {
          background-color: rgba(255, 152, 0, 0.3) !important;
          border-color: rgba(255, 152, 0, 0.7) !important;
        }
        
        .vis-labelset .vis-label.label-group-person,
        .vis-item.label-item.label-person {
          background-color: rgba(33, 150, 243, 0.3) !important;
          border-color: rgba(33, 150, 243, 0.7) !important;
        }
        
        .vis-labelset .vis-label.label-group-car,
        .vis-item.label-item.label-car {
          background-color: rgba(244, 67, 54, 0.3) !important;
          border-color: rgba(244, 67, 54, 0.7) !important;
        }
        
        .label-legend {
          margin-top: 10px;
          margin-bottom: 15px;
          font-size: 12px;
          color: #666;
        }
        .label-legend-item {
          display: inline-block;
          margin-right: 15px;
        }
        .label-legend-color {
          display: inline-block;
          width: 20px;
          height: 12px;
          margin-right: 5px;
          vertical-align: middle;
          border: 1px solid rgba(0, 0, 0, 0.2);
        }
        /* Default color for all labels */
        .label-legend-color[class*="label-"] {
          background-color: rgba(156, 39, 176, 0.3);
          border-color: rgba(156, 39, 176, 0.7);
        }
        /* Specific label colors override default */
        .label-legend-color.label-box {
          background-color: rgba(255, 152, 0, 0.3);
          border-color: rgba(255, 152, 0, 0.7);
        }
        .label-legend-color.label-person {
          background-color: rgba(33, 150, 243, 0.3);
          border-color: rgba(33, 150, 243, 0.7);
        }
        .label-legend-color.label-car {
          background-color: rgba(244, 67, 54, 0.3);
          border-color: rgba(244, 67, 54, 0.7);
        }
        .time-indicator {
          font-size: 24px;
          font-weight: bold;
          color: #333;
          font-family: 'Courier New', monospace;
          background: rgba(255, 255, 255, 0.95);
          padding: 15px 20px;
          border-radius: 8px;
          box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
          margin-left: 20px;
          float: right;
        }

      </style>
    </head>
    <body>
      <div class="header">
        <h2>NAS Video Timeline</h2>
        <div class="camera-selector">
          <label for="cameraSelect">Camera: </label>
          <select id="cameraSelect">
            <option value="">Loading cameras...</option>
          </select>
        </div>
      </div>
      <div style="position: relative;">
        <div id="overviewTimeline"></div>
        <div id="detailRangeIndicator"></div>
        <div id="overviewScrubLine" class="scrubLine"></div>
        <div id="overviewTooltip" class="timeTooltip"></div>
        <div id="overviewPlaybackIndicator" class="playbackIndicator"></div>
      </div>
      <div style="position: relative;">
        <div id="timeline"></div>
        <div id="scrubLine" class="scrubLine"></div>
        <div id="timeTooltip" class="timeTooltip"></div>
        <div id="playbackIndicator" class="playbackIndicator"></div>
      </div>
      <div id="labelLegend" class="label-legend"></div>
      <div class="time-indicator" id="timeIndicator">---------- --:--:--</div>
      <div id="playerContainer" style="position:relative; width:720px; height:405px;">
        <video id="playerA" controls playsinline style="position:absolute; top:0; left:0; width:100%; height:100%; z-index:2; transition: opacity 300ms;" ></video>
        <video id="playerB" controls playsinline style="position:absolute; top:0; left:0; width:100%; height:100%; z-index:1; transition: opacity 300ms;" ></video>
      </div>

<script>
let camera_id = null;

class TimelineManager {
  constructor(camera_id, intervals, labels) {
    this.camera_id = camera_id;
    this.intervals = intervals;
    this.labels = labels;
    this.timeline = null;
    this.overviewTimeline = null;
    this.isDragging = false;
    this.dragStartX = 0;
    this.dragStartTime = 0;
    this.updateIndicatorInterval = null;
  }

  init() {
    this.buildTimelines();
    this.setupEventListeners();
    this.startPlaybackIndicator();
  }

  buildTimelines() {
    // Build groups and items using vis.DataSet
    const { groups, items, overviewItems } = this.buildDataSets();

    // Create overview timeline
    const overviewContainer = document.getElementById('overviewTimeline');
    this.overviewTimeline = new vis.Timeline(overviewContainer, overviewItems, {
      selectable: false,
      zoomMin: 1000 * 60 * 60 * 24,
      zoomMax: 1000 * 60 * 60 * 24 * 365,
      stack: false,
      showCurrentTime: false,
      showMajorLabels: false,
      showMinorLabels: false,
      locale: 'es'
    });

    // Create detailed timeline
    const container = document.getElementById('timeline');
    this.timeline = new vis.Timeline(container, items, groups, {
      selectable: true,
      zoomMin: 1000 * 60 * 5,
      zoomMax: 1000 * 60 * 60 * 24,
      stack: false,
      showCurrentTime: false,
      locale: 'es',
      showMajorLabels: true,
      showMinorLabels: true,
      groupOrder: 'id',
      groupHeightMode: 'fixed',
      orientation: { item: 'top' },
      onInitialDrawComplete: () => {
        if (this.intervals.length > 0) {
          const firstStart = new Date(this.intervals[0].start).getTime();
          const lastEnd = new Date(this.intervals[this.intervals.length - 1].end).getTime();
          const middleTime = new Date((firstStart + lastEnd) / 2);
          
          const windowStart = new Date(middleTime.getTime() - 12 * 60 * 60 * 1000);
          const windowEnd = new Date(middleTime.getTime() + 12 * 60 * 60 * 1000);
          this.timeline.setWindow(windowStart, windowEnd, {animation: false});
        }
      }
    });
  }

  setupEventListeners() {
    // Sync timelines
    this.timeline.on('rangechange', () => {
      this.updateDetailRangeIndicator();
    });
    
    this.overviewTimeline.on('rangechange', () => {
      this.updateDetailRangeIndicator();
    });
    
    setTimeout(() => this.updateDetailRangeIndicator(), 100);

    // Setup detail range indicator dragging
    this.setupDetailRangeIndicator();

    // Setup overview click to center
    this.setupOverviewClick();

    // Setup timeline tooltips
    this.setupTimelineTooltips();
  }

  updateDetailRangeIndicator() {
    const detailRange = this.timeline.getWindow();
    const overviewRange = this.overviewTimeline.getWindow();
    const indicator = document.getElementById('detailRangeIndicator');
    const container = document.getElementById('overviewTimeline');
    
    const containerWidth = container.clientWidth;
    const overviewSpan = overviewRange.end - overviewRange.start;
    
    const startOffset = (detailRange.start - overviewRange.start) / overviewSpan;
    const endOffset = (detailRange.end - overviewRange.start) / overviewSpan;
    
    indicator.style.left = (startOffset * containerWidth) + 'px';
    indicator.style.width = ((endOffset - startOffset) * containerWidth) + 'px';
  }

  setupDetailRangeIndicator() {
    const indicator = document.getElementById('detailRangeIndicator');
    const overviewContainer = document.getElementById('overviewTimeline');
    
    indicator.addEventListener('mousedown', (event) => {
      this.isDragging = true;
      this.dragStartX = event.clientX;
      const detailRange = this.timeline.getWindow();
      this.dragStartTime = detailRange.start.getTime();
      event.stopPropagation();
      event.preventDefault();
    });
    
    document.addEventListener('mousemove', (event) => {
      if (!this.isDragging) return;
      
      const overviewRange = this.overviewTimeline.getWindow();
      const containerWidth = overviewContainer.clientWidth;
      const overviewSpan = overviewRange.end - overviewRange.start;
      
      const deltaX = event.clientX - this.dragStartX;
      const deltaTime = (deltaX / containerWidth) * overviewSpan;
      
      const detailRange = this.timeline.getWindow();
      const windowSize = detailRange.end - detailRange.start;
      const newStart = new Date(this.dragStartTime + deltaTime);
      const newEnd = new Date(newStart.getTime() + windowSize);
      
      this.timeline.setWindow(newStart, newEnd, {animation: false});
    });
    
    document.addEventListener('mouseup', () => {
      this.isDragging = false;
    });
  }

  setupOverviewClick() {
    const overviewContainer = document.getElementById('overviewTimeline');
    
    overviewContainer.onclick = (event) => {
      if (event.target.id === 'detailRangeIndicator') return;
      
      const props = this.overviewTimeline.getEventProperties(event);
      if (!props.time) return;
      
      const detailRange = this.timeline.getWindow();
      const windowSize = detailRange.end - detailRange.start;
      const start = new Date(props.time.getTime() - windowSize / 2);
      const end = new Date(props.time.getTime() + windowSize / 2);
      this.timeline.setWindow(start, end, {animation: true});
    };
  }

  setupTimelineTooltips() {
    const container = document.getElementById('timeline');
    const tooltip = document.getElementById('timeTooltip');
    const scrubLine = document.getElementById('scrubLine');

    container.addEventListener('mousemove', (event) => {
      const props = this.timeline.getEventProperties(event);
      if (props.time) {
        const timeDate = new Date(props.time);
        const rect = container.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        
        tooltip.textContent = this.formatTime(timeDate);
        tooltip.style.display = 'block';
        tooltip.style.left = `${event.clientX - rect.left + 10}px`;
        tooltip.style.top = `${event.clientY - rect.top - 30}px`;
        
        scrubLine.style.display = 'block';
        scrubLine.style.left = `${mouseX}px`;
      }
    });

    container.addEventListener('mouseleave', () => {
      tooltip.style.display = 'none';
      scrubLine.style.display = 'none';
    });
  }

  startPlaybackIndicator() {
    this.updateIndicatorInterval = setInterval(() => {
      if (window.videoPlayer) {
        this.updatePlaybackIndicator(window.videoPlayer.getCurrentTime());
      }
    }, 100);
  }

  updatePlaybackIndicator(actualTime) {
    if (!actualTime) {
      document.getElementById('playbackIndicator').style.display = 'none';
      document.getElementById('overviewPlaybackIndicator').style.display = 'none';
      document.getElementById('timeIndicator').textContent = '';
      return;
    }

    const playbackIndicator = document.getElementById('playbackIndicator');
    const overviewPlaybackIndicator = document.getElementById('overviewPlaybackIndicator');
    const timeIndicator = document.getElementById('timeIndicator');
    const container = document.getElementById('timeline');
    const overviewContainer = document.getElementById('overviewTimeline');
    
    timeIndicator.textContent = this.formatDateTime(actualTime);
    
    // Update detail timeline indicator
    const timelineRange = this.timeline.getWindow();
    const centerPanel = container.querySelector('.vis-center');
    if (centerPanel) {
      const containerWidth = centerPanel.clientWidth;
      const timeSpan = timelineRange.end - timelineRange.start;
      
      if (actualTime >= timelineRange.start && actualTime <= timelineRange.end) {
        const offset = (actualTime - timelineRange.start) / timeSpan;
        const centerLeft = centerPanel.getBoundingClientRect().left - container.getBoundingClientRect().left;
        playbackIndicator.style.left = (centerLeft + offset * containerWidth) + 'px';
        playbackIndicator.style.display = 'block';
      } else {
        playbackIndicator.style.display = 'none';
      }
    }
    
    // Update overview timeline indicator
    const overviewRange = this.overviewTimeline.getWindow();
    const overviewWidth = overviewContainer.clientWidth;
    const overviewSpan = overviewRange.end - overviewRange.start;
    
    if (actualTime >= overviewRange.start && actualTime <= overviewRange.end) {
      const overviewOffset = (actualTime - overviewRange.start) / overviewSpan;
      overviewPlaybackIndicator.style.left = (overviewOffset * overviewWidth) + 'px';
      overviewPlaybackIndicator.style.display = 'block';
    } else {
      overviewPlaybackIndicator.style.display = 'none';
    }
  }

  formatTime(date) {
    const hours = date.getHours().toString().padStart(2, '0');
    const minutes = date.getMinutes().toString().padStart(2, '0');
    const seconds = date.getSeconds().toString().padStart(2, '0');
    return `${hours}:${minutes}:${seconds}`;
  }

  formatDateTime(date) {
    const year = date.getFullYear();
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const day = date.getDate().toString().padStart(2, '0');
    const hours = date.getHours().toString().padStart(2, '0');
    const minutes = date.getMinutes().toString().padStart(2, '0');
    const seconds = date.getSeconds().toString().padStart(2, '0');
    return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
  }

  async handleTimelineClick(event, onSeek) {
    const props = this.timeline.getEventProperties(event);
    if (!props.time) return;
    
    const t = props.time.toISOString();
    const resp = await fetch('/seek?time=' + encodeURIComponent(t) + '&camera_id=' + encodeURIComponent(this.camera_id));
    if (!resp.ok) return;
    const { path, offset } = await resp.json();
    
    if (onSeek) {
      await onSeek(path, offset || 0, props.time);
    }
  }

  update(camera_id, intervals, labels, keepWindow = false) {
    // Store current window before updating
    const currentWindow = this.timeline ? this.timeline.getWindow() : null;
    
    // Update data
    this.camera_id = camera_id;
    this.intervals = intervals;
    this.labels = labels;
    
    // Rebuild groups and items
    const { groups, items, overviewItems } = this.buildDataSets();
    
    // Update existing timelines instead of destroying
    if (this.timeline) {
      this.timeline.setGroups(groups);
      this.timeline.setItems(items);
      
      // Keep current window or set to middle of new data
      if (keepWindow && currentWindow) {
        // Preserve the exact same window position
        this.timeline.setWindow(currentWindow.start, currentWindow.end, {animation: false});
      } else if (intervals.length > 0) {
        // Set window to show middle of new data
        const firstStart = new Date(intervals[0].start).getTime();
        const lastEnd = new Date(intervals[intervals.length - 1].end).getTime();
        const middleTime = new Date((firstStart + lastEnd) / 2);
        
        const windowStart = new Date(middleTime.getTime() - 12 * 60 * 60 * 1000);
        const windowEnd = new Date(middleTime.getTime() + 12 * 60 * 60 * 1000);
        this.timeline.setWindow(windowStart, windowEnd, {animation: true});
      }
    }
    
    if (this.overviewTimeline) {
      this.overviewTimeline.setItems(overviewItems);
    }
    
    // Update detail range indicator
    setTimeout(() => this.updateDetailRangeIndicator(), 100);
  }

  buildDataSets() {
    const groups = new vis.DataSet();
    const items = new vis.DataSet();
    const overviewItems = new vis.DataSet();
    
    // Add video segments as background type (no group)
    this.intervals.forEach((interval, i) => {
      items.add({
        id: 'segment_' + i,
        content: '',
        start: interval.start,
        end: interval.end,
        type: 'background',
        className: 'video-segment'
      });
      
      overviewItems.add({
        id: 'overview_' + i,
        content: '',
        start: interval.start,
        end: interval.end,
        type: 'background',
        className: 'overview-item'
      });
    });
    
    // Create groups for each label type
    if (this.labels && this.labels.labels) {
      Object.keys(this.labels.labels).forEach(labelName => {
        groups.add({
          id: labelName,
          content: labelName,
          className: 'label-group-' + labelName
        });
      });
      
      // Add label items to their respective groups
      Object.entries(this.labels.labels).forEach(([labelName, labelTimeline]) => {
        labelTimeline.intervals.forEach((interval, j) => {
          items.add({
            id: `label_${labelName}_${j}`,
            content: '',
            start: interval.start,
            end: interval.end,
            type: 'range',
            group: labelName,
            className: 'label-item label-' + labelName
          });
        });
      });
    }
    
    return { groups, items, overviewItems };
  }

  destroy() {
    if (this.updateIndicatorInterval) {
      clearInterval(this.updateIndicatorInterval);
    }
    if (this.timeline) {
      this.timeline.destroy();
      this.timeline = null;
    }
    if (this.overviewTimeline) {
      this.overviewTimeline.destroy();
      this.overviewTimeline = null;
    }
  }

  getTimeline() {
    return this.timeline;
  }

  getIntervals() {
    return this.intervals;
  }
}

async function loadCameras() {
  const res = await fetch('/cameras');
  const cameras = await res.json();
  const select = document.getElementById('cameraSelect');
  select.innerHTML = '';
  
  if (cameras.length === 0) {
    select.innerHTML = '<option value="">No cameras found</option>';
    return null;
  }
  
  cameras.forEach(cam => {
    const option = document.createElement('option');
    option.value = cam.id;
    option.textContent = cam.name;
    select.appendChild(option);
  });
  
  // Select first camera by default
  camera_id = cameras[0].id;
  select.value = camera_id;
  
  // Handle camera change
  select.addEventListener('change', async (e) => {
    // Capture current playback time before changing camera
    const currentTime = window.videoPlayer ? window.videoPlayer.getCurrentTime() : null;
    
    camera_id = e.target.value;
    await initTimeline(true); // Keep the same window position
    
    // If we had a playback time, seek to that time in the new camera
    if (currentTime && window.loadAndPlay) {
      const t = currentTime.toISOString();
      const resp = await fetch('/seek?time=' + encodeURIComponent(t) + '&camera_id=' + encodeURIComponent(camera_id));
      if (resp.ok) {
        const { path, offset } = await resp.json();
        await window.loadAndPlay(path, offset || 0, currentTime);
      }
    }
  });
  
  return camera_id;
}



function updateLabelLegend(labels) {
  const legendContainer = document.getElementById('labelLegend');
  legendContainer.innerHTML = '';
  
  if (!labels || !labels.labels || Object.keys(labels.labels).length === 0) {
    return;
  }
  
  legendContainer.innerHTML = '<strong>Detected labels:</strong> ';
  
  Object.keys(labels.labels).forEach(labelName => {
    const item = document.createElement('span');
    item.className = 'label-legend-item';
    
    const colorBox = document.createElement('span');
    colorBox.className = 'label-legend-color label-' + labelName;
    
    item.appendChild(colorBox);
    item.appendChild(document.createTextNode(labelName));
    legendContainer.appendChild(item);
  });
}

async function initTimeline(keepWindow = false) {
  if (!camera_id) return;
  
  const res = await fetch('/list-intervals?camera_id=' + encodeURIComponent(camera_id));
  const intervals = await res.json();

  // Fetch labels for this camera
  const labelsRes = await fetch('/labels?camera_id=' + encodeURIComponent(camera_id));
  const labels = await labelsRes.json();
  
  // Update legend
  updateLabelLegend(labels);
  
  // Update or create timeline manager
  if (window.timelineManager) {
    // Update existing timeline with new data (smooth transition)
    window.timelineManager.update(camera_id, intervals, labels, keepWindow);
  } else {
    // Create and initialize timeline manager for the first time
    window.timelineManager = new TimelineManager(camera_id, intervals, labels);
    window.timelineManager.init();
    
    // Setup video player (only needed once)
    const playerA = document.getElementById('playerA');
    const playerB = document.getElementById('playerB');
    let active = 'A';
    
    function activePlayer() { return active === 'A' ? playerA : playerB; }
    function inactivePlayer() { return active === 'A' ? playerB : playerA; }
    
    // Helper to load into the inactive player, seek when metadata is ready, play and then swap
    async function loadAndPlay(path, offsetSeconds, seekTimestamp) {
      const target = inactivePlayer();
      target.pause();
      target.removeAttribute('src');
      target.src = '/video?path=' + encodeURIComponent(path);
      
      target.dataset.seekTimestamp = seekTimestamp ? seekTimestamp.toISOString() : null;

      const onMeta = function() {
        const seek = Math.max(0, Math.min(offsetSeconds || 0, target.duration || 0));
        
        target.dataset.videoDuration = target.duration;
        target.dataset.videoOffset = seek;
        
        const onSeeked = function() {
          target.removeEventListener('seeked', onSeeked);
          
          const onPlaying = function() {
            if (active === 'A') {
              playerB.style.zIndex = 3;
              playerA.style.zIndex = 1;
            } else {
              playerA.style.zIndex = 3;
              playerB.style.zIndex = 1;
            }
            active = (target === playerA) ? 'A' : 'B';
            const nowInactive = inactivePlayer();
            try { nowInactive.pause(); } catch (e) {}
            target.removeEventListener('playing', onPlaying);
          };
          target.addEventListener('playing', onPlaying);
          target.play().catch(() => {});
        };
        
        target.addEventListener('seeked', onSeeked);
        try { target.currentTime = seek; } catch (e) {}
        target.removeEventListener('loadedmetadata', onMeta);
      };
      target.addEventListener('loadedmetadata', onMeta);
    }
    
    // Make loadAndPlay available globally for camera switching
    window.loadAndPlay = loadAndPlay;
    
    // Setup timeline click handler for video seeking (only needed once)
    const container = document.getElementById('timeline');
    container.onclick = async (event) => {
      await window.timelineManager.handleTimelineClick(event, loadAndPlay);
    };
    
    // Create video player wrapper (only needed once)
    window.videoPlayer = {
      getCurrentTime: () => {
        const player = activePlayer();
        if (player && player.dataset.seekTimestamp && !player.paused) {
          const seekTimestamp = new Date(player.dataset.seekTimestamp);
          const videoOffset = parseFloat(player.dataset.videoOffset || 0);
          const currentTime = player.currentTime;
          return new Date(seekTimestamp.getTime() + (currentTime - videoOffset) * 1000);
        }
        return null;
      }
    };
    
    // Start updating playback indicator (only needed once)
    window.timelineManager.startPlaybackIndicator();
    
    // Setup video player event handlers (only needed once)
    setupVideoPlayer(activePlayer, inactivePlayer, () => active, (newActive) => { active = newActive; }, loadAndPlay);
  }
  
  // Store references for backward compatibility
  window._sg_timeline = window.timelineManager.getTimeline();
  window._sg_intervals = window.timelineManager.getIntervals();
  window._sg_labels = labels;
}

function setupVideoPlayer(activePlayerFn, inactivePlayerFn, getActive, setActive, loadAndPlay) {
  const playerA = document.getElementById('playerA');
  const playerB = document.getElementById('playerB');

  // Remove old event listeners if they exist
  if (window._sg_playerAEndedHandler) {
    playerA.removeEventListener('ended', window._sg_playerAEndedHandler);
  }
  if (window._sg_playerBEndedHandler) {
    playerB.removeEventListener('ended', window._sg_playerBEndedHandler);
  }

  // When video ends, find the next available video and play it
  const playerAEndedHandler = async () => {
    if (getActive() !== 'A') return; // only respond if A is active
    
    const seekTimestamp = playerA.dataset.seekTimestamp;
    const videoOffset = parseFloat(playerA.dataset.videoOffset || 0);
    const videoDuration = parseFloat(playerA.dataset.videoDuration || 0);
    
    if (!seekTimestamp) return;
    
    const startTime = new Date(seekTimestamp);
    const playedDuration = videoDuration - videoOffset;
    const endTime = new Date(startTime.getTime() + playedDuration * 1000);
    
    const t = startTime.toISOString();
    const resp = await fetch('/seek?time=' + encodeURIComponent(t) + '&camera_id=' + encodeURIComponent(camera_id) + '&return_next=true');
    if (!resp.ok) return;
    const { path, offset } = await resp.json();
    
    await loadAndPlay(path, offset || 0, endTime);
  };

  const playerBEndedHandler = async () => {
    if (getActive() !== 'B') return; // only respond if B is active
    
    const seekTimestamp = playerB.dataset.seekTimestamp;
    const videoOffset = parseFloat(playerB.dataset.videoOffset || 0);
    const videoDuration = parseFloat(playerB.dataset.videoDuration || 0);
    
    if (!seekTimestamp) return;
    
    const startTime = new Date(seekTimestamp);
    const playedDuration = videoDuration - videoOffset;
    const endTime = new Date(startTime.getTime() + playedDuration * 1000);
    
    // Seek to the beginning of the next video using return_next=true
    const t = startTime.toISOString();
    const resp = await fetch('/seek?time=' + encodeURIComponent(t) + '&camera_id=' + encodeURIComponent(camera_id) + '&return_next=true');
    if (!resp.ok) return;
    const { path, offset } = await resp.json();
    
    await loadAndPlay(path, offset || 0, endTime);
  };

  // Store handlers globally so we can remove them later
  window._sg_playerAEndedHandler = playerAEndedHandler;
  window._sg_playerBEndedHandler = playerBEndedHandler;

  // Add event listeners
  playerA.addEventListener('ended', playerAEndedHandler);
  playerB.addEventListener('ended', playerBEndedHandler);
}

// Initialize app
(async () => {
  await loadCameras();
  await initTimeline();
})();
</script>
    </body>
    </html>
    